.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AWSAPI 1"
.TH AWSAPI 1 "2015-05-25" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
awsapi \- Low\-level Bourne shell access to Amazon EC2 etc.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
awsapi [options] <action> [parameters]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBawsapi\fR makes it easy for Bourne shell scripts to call the low-level \s-1API\s0
of Amazon \s-1EC2\s0 and other services that follow the same call conventions.
It knows little about the \s-1API\s0, but sends given actions and parameters
exactly as given, in the hope that users will know all the details.
.SS "Requests"
.IX Subsection "Requests"
A typical shell command would look something like this:
.PP
.Vb 2
\&    $(awsapi ec2.RunInstances ImageId=$imageId MinCount=1 MaxCount=1 \e
\&        instanceId:instancesSet.1.instanceId)
.Ve
.PP
The action \fIec2.RunInstances\fR consists of a prefix (\fIec2\fR), which is used
to select \s-1API\s0 version and endpoint for the call, and an action name
(\fIRunInstances\fR) which is passed directly to the underlying \s-1API\s0.
.PP
If the action prefix is \fIxyz\fR, an \s-1XYZ_API_VERSION\s0 environment variable
must be set to a corresponding \s-1API\s0 version. The \s-1XYZ_ENDPOINT\s0 may be
set to a specific \s-1URL\s0. If not set explicitly, it will usually default
to https://xyz.amazonaws.com/, which is often what you want anyway.
.PP
Request parameters are simply given as \fIname\fR=\fIvalue\fR pairs, as expected.
Common request parameters (\fIAction\fR, \fIVersion\fR, \fIAWSAccessKeyId\fR, \fITimestamp\fR,
\&\fISignature\fR, \fISignatureMethod\fR, and \fISignatureVersion\fR) are automatically
added to each query.
.SS "Responses"
.IX Subsection "Responses"
The surrounding $(...) is because \fBawsapi\fR will print commands on stdout
that it expects the calling shell to execute. Values are returned to
the caller by setting variables that way. The second line in the above
example says that our local shell variable \fIinstanceId\fR should be set
to the value returned in \fIinstancesSet.1.instanceId\fR. The \fIinstanceId:\fR part
is optional in this case, since the name of the response element is
used by default, but sometimes you may have a better name in mind.
.PP
Use the \f(CW\*(C`.n.\*(C'\fR notation to collect multiple values into a single list:
.PP
.Vb 3
\&    $(awsapi ec2.DescribeInstances Filter.1.Name=instance\-state\-name \e
\&        Filter.1.Value.1=running ipAddressList:reservationSet.n. \e
\&            instancesSet.n.ipAddress)
.Ve
.PP
As seen here, you may break long response elements after any dot and
continue on the next line. Collected values are put in space-separated
lists of items, suitable for use in a shell \f(CW\*(C`for\*(C'\fR loop.
.ie n .SS """Objects"""
.el .SS "``Objects''"
.IX Subsection "Objects"
The \f(CW\*(C`+\*(C'\fR notation gives you a separate \*(L"object\*(R" for each combination of
values matched by one or more \f(CW\*(C`.n.\*(C'\fR specs:
.PP
.Vb 5
\&    $(awsapi ec2.DescribeInstances \e
\&        instance+state: \e
\&            reservationSet.n.instancesSet.n.instanceState.name \e
\&        instance+ \e
\&            reservationSet.n.instancesSet.n.ipAddress)
.Ve
.PP
This returns an \fIinstanceList\fR shell variable, which contains one value
for each instance: instanceTable[1.1], instanceTable[1.2], etc. You can
then loop over this list and expand the value of each individual field:
.PP
.Vb 3
\&    for instance in $instanceList; do
\&        printf "%\-10s %\-16s\en" $(instance.state) $(instance.ipAddress)
\&    done
.Ve
.PP
There is a catch, though. This convenient notation didn't come out of
nowhere, and you may need to understand some details. In this example,
\&\fIinstance.state\fR is the name of a temporary shell script, which reads the
exported \fIinstance\fR variable before printing a suitable value on stdout.
Therefore, the name of your loop variable is not really negotiable.
.SS "Brace Expansion"
.IX Subsection "Brace Expansion"
The previous \fIDescribeInstances\fR example still looks way too complicated.
In practice, it would probably be written like this instead:
.PP
.Vb 4
\&    INSTANCES=instance+reservationSet.n.instancesSet.n
\&    $(awsapi ec2.DescribeInstances $INSTANCES.{ \e
\&        state:instanceState.name, ipAddress \e
\&    })
.Ve
.PP
The \f(CW\*(C`{...}\*(C'\fR is similar to a bash-style brace expansion. If you run this
command in \fIbash\fR\|(1) and skip some whitespace, \fBbash\fR does the expansion.
Otherwise, \fBawsapi\fR will do the same thing. In any case, \f(CW\*(C`a.{b,c}\*(C'\fR will
end up being the same as \f(CW\*(C`a.b a.c\*(C'\fR. In this example, the \f(CW\*(C`state:\*(C'\fR part
will end up in the middle of the output spec, like this:
.PP
.Vb 1
\&    instance+reservationSet.n.instancesSet.n.state:instanceState.name
.Ve
.PP
This is \s-1OK\s0. The colon is really just a renaming operator, so in this
case it means that \f(CW\*(C`reservationSet.n.instancesSet.n.instanceState.name\*(C'\fR
works as if it had been named \f(CW\*(C`reservationSet.n.instancesSet.n.state\*(C'\fR.
.SS "Filtering"
.IX Subsection "Filtering"
You can add a display filter to your queries like this:
.PP
.Vb 3
\&    $(awsapi ec2.DescribeInstances $INSTANCES.{ \e
\&        state:instanceState.name eq running, ipAddress \e
\&    })
.Ve
.PP
In this case, the \fIinstanceList\fR will only contain instances that were in
fact running when the query was made. The six filtering operators are what
you may expect: \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`gt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, and \f(CW\*(C`ge\*(C'\fR correspond
to C operators \f(CW\*(C`==\*(C'\fR, \f(CW\*(C`!=\*(C'\fR, \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`<=\*(C'\fR, and \f(CW\*(C`>=\*(C'\fR,
but may be used
unquoted in the shell. Comparison is numeric if both arguments look
like numbers. Otherwise these operators do a stringwise comparison.
Fortunately, timestamps in the \s-1EC2\s0 \s-1API\s0 will have alphabetic order.
.PP
If you want to filter on a response element without returning it as a
shell variable in the results, you may simply rename it to nothing:
.PP
.Vb 3
\&    $(awsapi ec2.DescribeInstances $INSTANCES.{ \e
\&        :instanceState.name eq running, ipAddress \e
\&    })
.Ve
.PP
It is possible to filter for one of many values by using slashes to
separate the individual values like this:
.PP
.Vb 3
\&    $(awsapi ec2.DescribeInstances $INSTANCES.{ \e
\&        state:instanceState.name, ipAddress eq 192.168.0.1/192.168.0.2 \e
\&    })
.Ve
.PP
This builds that from the space-separated values of \f(CW$ipAddressList\fR:
.PP
.Vb 3
\&    $(awsapi ec2.DescribeInstances $INSTANCES.{ \e
\&        state:instanceState.name, ipAddress eq @ipAddressList \e
\&    })
.Ve
.PP
For clarity, you may also use \f(CW\*(C`in\*(C'\fR instead of \f(CW\*(C`eq\*(C'\fR in this case.
.SS "Default Values"
.IX Subsection "Default Values"
The \f(CW\*(C`or\*(C'\fR filter provides a default value when a result is missing:
.PP
.Vb 2
\&    $(awsapi ec2.DescribeSnapshots SnapshotId.1=$snapshotId \e
\&        snapshotSet.1.progress or "0%")
.Ve
.PP
A newly created \s-1EC2\s0 snapshot does not necessarily have any kind of
progress value, but it's convenient to pretend that it does, since
\&\fBawsapi\fR would otherwise complain:
.PP
.Vb 1
\&    awsapi: no snapshotSet.1.progress returned
.Ve
.PP
Empty strings will also count as missing results, so you can use the
default value to replace a response element that exists but is blank.
.SS "Verification"
.IX Subsection "Verification"
It is often necessary to verify the returned values. For convenience,
\&\fBawsapi\fR will do this for you if an expected value is given like this:
.PP
.Vb 2
\&    $(awsapi ec2.AssociateAddress PublicIp=$ipAddress \e
\&        InstanceId=$instanceId status:return := true)
.Ve
.PP
In this case, if the value of response element \fIreturn\fR is in fact not
\&\fItrue\fR, \fBawsapi\fR will complain on stderr and print \*(L"eval false\*(R" to stdout.
This is the standard behavior for other types of error as well.
.PP
Waiting for something to happen is also a common activity. If you give
multiple expected values, \fBawsapi\fR will repeat the call regularly until
the final value has been returned. Each time, the returned value must
match one of the expected values. Otherwise an error is signalled:
.PP
.Vb 2
\&    $(awsapi ec2.DescribeVolumes VolumeId.1=$volumeId \e
\&        volumeSet.1.status := attaching/attached)
.Ve
.PP
There may be a delay before newly created resources are visible for
further \s-1API\s0 calls. To avoid annoying complaints about these missing
resources, you may use a '\-' to represent the missing value:
.PP
.Vb 4
\&    $(awsapi ec2.DescribeInstances \e
\&        Filter.1.{ Name="instance\-id", Value.1="$instanceId" } \e
\&        reservationSet.1.instancesSet.1.instanceState.name \e
\&            := \-/pending/running)
.Ve
.SS "Joining Tables"
.IX Subsection "Joining Tables"
This is a low-level tool. Each call to \fBawsapi\fR corresponds to a single
call to the underlying \s-1API\s0. However, it is convenient to see the name
of each returned object, and Amazon \s-1EC2\s0 stores names as separate tags.
.PP
The solution to this problem would look something like this:
.PP
.Vb 4
\&    # Grab the "Name" tags for all "instance" resources
\&    $(awsapi ec2.DescribeTags tag@resourceId+tagSet.n.{ \e
\&        resourceId, resourceType eq instance, key eq Name, name:value \e
\&    })
\&
\&    # Include the tag.name result of the first query here
\&    $(awsapi \-\-table ec2.DescribeInstances $INSTANCES.{ \e
\&        instanceId, state:instanceState.name, \e
\&        ~tag.name@instanceId, ipAddress \e
\&    })
.Ve
.PP
In the first query, the \f(CW@resourceId\fR part says that the result should
be indexed by the value of \f(CW\*(C`resourceId\*(C'\fR (which should be unique), instead
of using the number matched by \f(CW\*(C`.n.\*(C'\fR, as usual.
.PP
The second query uses the \f(CW\*(C`tag.name\*(C'\fR table column that was generated
by the first query. A value in this column is selected by \f(CW\*(C`instanceId\*(C'\fR,
which should match some \f(CW\*(C`resourceId\*(C'\fR in the previous query.
.PP
The \fB\-\-table\fR option displays this combined result in a pretty way.
.SS "Settings"
.IX Subsection "Settings"
Your \s-1AWS\s0 \*(L"Secret Access Key\*(R" and \*(L"Access Key \s-1ID\s0\*(R" must be stored in a
secret \fI~/.awsapirc\fR file. Remember to use \f(CW\*(C`chmod 600 ~/.awsapirc\*(C'\fR to
keep your secrets secret. A sample \fI~/.awsapirc\fR would look like this:
.PP
.Vb 2
\&    secretAccessKey: eW91dHViZS5jb20vd2F0Y2g/dj1SU3NKMTlzeTNKSQ==
\&    accessKeyId: AKIADQKE4SARGYLE
.Ve
.PP
Furthermore, each script you write should start with one or more lines
that set the \s-1API\s0 versions of all relevant services:
.PP
.Vb 2
\&    export EC2_API_VERSION="2010\-11\-15"
\&    export SQS_API_VERSION="2009\-02\-01"
.Ve
.PP
See the \s-1EXAMPLES\s0 section for a complete example of a shell script.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-\-debug\fR" 4
.IX Item "--debug"
Enables debugging, which prints extra information to stderr.
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
Prints a brief help message and exits.
.IP "\fB\-\-table\fR" 4
.IX Item "--table"
Prints your query results in a nice table layout.
.IP "\fB\-\-man\fR" 4
.IX Item "--man"
Displays the complete \fBawsapi\fR man page.
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
Displays the date of this \fBawsapi\fR version.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\& #!/bin/sh
\& set \-e
\&
\& ### Script initialization ##################################
\&
\& # These are usually needed
\& export EC2_API_VERSION="2010\-11\-15"
\& METADATA=http://169.254.169.254/latest/meta\-data
\& PATH="$(dirname $0):$PATH"
\&
\& ### IP address grabbing ####################################
\&
\& # Describe the instance we\*(Aqre running on
\& instanceId=$(curl \-s "$METADATA/instance\-id")
\& $(awsapi ec2.DescribeInstances InstanceId.1=$instanceId \e
\&     reservationSet.1.instancesSet.1.ipAddress)
\&
\& # Print the IP address
\& echo "IP address: $ipAddress"
\&
\& ### Volume creation ########################################
\&
\& # Create an empty volume and get its ID
\& $(awsapi ec2.CreateVolume AvailabilityZone=us\-east\-1d \e
\&     Size=8 volumeId)
\&
\& # Wait for the volume to become available
\& $(awsapi ec2.DescribeVolumes VolumeId.1=$volumeId \e
\&     volumeSet.1.status := creating/available)
\&
\& ############################################################
.Ve
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The following environment variables should be set when \fBawsapi\fR is used.
\&\s-1XYZ\s0 is a fake prefix that should be replaced by \s-1EC2\s0, \s-1SQS\s0, etc.
.IP "\s-1XYZ_API_VERSION\s0" 4
.IX Item "XYZ_API_VERSION"
Used verbatim as the \*(L"Version\*(R" parameter in \s-1API\s0 calls. The script
doesn't really care about versions, but Amazon \s-1XYZ\s0 may reject your
requests if you are programming against the wrong version.
.IP "\s-1XYZ_ENDPOINT\s0" 4
.IX Item "XYZ_ENDPOINT"
Used to set an endpoint \s-1URL\s0 if https://xyz.amazonaws.com/ is not
good enough for you. For example, Amazon \s-1EC2\s0 will typically need
https://ec2.eu\-west\-1.amazonaws.com/ to use the Irish region.
.IP "\s-1AWSAPI_FAILURE_COMMAND\s0" 4
.IX Item "AWSAPI_FAILURE_COMMAND"
The command executed when awsapi fails. The default, \*(L"eval false\*(R",
is handled like any other failing command. However, it's sometimes
useful to treat \s-1AWS\s0 failures differently. For example, you may use
\&\*(L"return 1\*(R" to exit a function, or simply call \*(L"handle_aws_failure\*(R".
.IP "\s-1AWSAPI_FILE_DIR\s0" 4
.IX Item "AWSAPI_FILE_DIR"
The name of a directory containing automatically generated scripts.
Your first \fBawsapi\fR call will create this directory and also set
the environment variable. The directory is automatically deleted
when the current shell exits.
.IP "\s-1AWSAPI_USER_AGENT\s0" 4
.IX Item "AWSAPI_USER_AGENT"
The \*(L"User-Agent\*(R" header that identifies a client in each request to
the \s-1AWS\s0 servers. For more advanced scripts, you may want to change
the default \*(L"awsapi\*(R" identification to some more specific name.
.IP "\s-1HOME\s0" 4
.IX Item "HOME"
Used to determine the user's home directory, which is where an
\&\fI.awsapirc\fR file with the \s-1AWS\s0 \*(L"Secret Access Key\*(R" and \*(L"Access Key \s-1ID\s0\*(R"
should be placed.
.SH "FILES"
.IX Header "FILES"
.IP "\fI~/.awsapirc\fR \*(-- contains your \s-1AWS\s0 secrets." 4
.IX Item "~/.awsapirc  contains your AWS secrets."
This file contains secret data. It should only be accessible by the
\&\fBawsapi\fR user, so remember to \*(L"chmod 600 ~/.awsapirc\*(R" before adding
your keys. All settings are given as lines of \*(L"name: value\*(R" pairs.
The \fIsecretAccessKey\fR and \fIaccessKeyId\fR settings are required.
.SH "BUGS"
.IX Header "BUGS"
Amazon S3 does not have a query \s-1API\s0. This version of \fBawsapi\fR has some
rudimentary code that tries to use \s-1SOAP\s0 instead, but that support is
very limited and not expected to help you in any way.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
http://aws.amazon.com/documentation/
.SH "AUTHOR"
.IX Header "AUTHOR"
Henrik Gulbrandsen <henrik@gulbra.net>
